/**
    * @license
    * Copyright 2020 Prism.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("@tensorflow/tfjs-converter"),require("@tensorflow/tfjs-core")):"function"==typeof define&&define.amd?define(["exports","@tensorflow/tfjs-converter","@tensorflow/tfjs-core"],e):e((t=t||self).eyeblink={},t.tf,t.tfjsCore)}(this,(function(t,e,s){"use strict";
/**
        * @license
        * Copyright 2020 Google LLC. All Rights Reserved.
        * Licensed under the Apache License, Version 2.0 (the "License");
        * you may not use this file except in compliance with the License.
        * You may obtain a copy of the License at
        *
        * http://www.apache.org/licenses/LICENSE-2.0
        *
        * Unless required by applicable law or agreed to in writing, software
        * distributed under the License is distributed on an "AS IS" BASIS,
        * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        * See the License for the specific language governing permissions and
        * limitations under the License.
        * =============================================================================
        */const n=t=>({startEndTensor:t,startPoint:s.slice(t,[0,0],[-1,2]),endPoint:s.slice(t,[0,2],[-1,2])}),o={strides:[8,16],anchors:[2,6]};function i(t,e){let n,o,i;if(t.topLeft instanceof s.Tensor&&t.bottomRight instanceof s.Tensor){const[r,a]=s.tidy(()=>[s.concat([s.sub(e-1,t.topLeft.slice(0,1)),t.topLeft.slice(1,1)]),s.concat([s.sub(e-1,t.bottomRight.slice(0,1)),t.bottomRight.slice(1,1)])]);n=r,o=a,null!=t.landmarks&&(i=s.tidy(()=>{const n=s.sub(s.tensor1d([e-1,0]),t.landmarks),o=s.tensor1d([1,-1]);return s.mul(n,o)}))}else{const[s,r]=t.topLeft,[a,c]=t.bottomRight;n=[e-1-s,r],o=[e-1-a,c],null!=t.landmarks&&(i=t.landmarks.map(t=>[e-1-t[0],t[1]]))}const r={topLeft:n,bottomRight:o};return null!=i&&(r.landmarks=i),null!=t.probability&&(r.probability=t.probability instanceof s.Tensor?t.probability.clone():t.probability),r}function r(t,e){return s.tidy(()=>{let o;return o=t.hasOwnProperty("box")?t.box:t,((t,e)=>{const o=s.mul(t.startPoint,e),i=s.mul(t.endPoint,e),r=s.concat2d([o,i],1);return n(r)})(o,e).startEndTensor.squeeze()})}class a{constructor(t,e,n,i,r,a){this.blazeFaceModel=t,this.width=e,this.height=n,this.maxFaces=i,this.anchorsData=function(t,e,s){const n=[];for(let o=0;o<s.strides.length;o++){const i=s.strides[o],r=Math.floor((e+i-1)/i),a=Math.floor((t+i-1)/i),c=s.anchors[o];for(let t=0;t<r;t++){const e=i*(t+.5);for(let t=0;t<a;t++){const s=i*(t+.5);for(let t=0;t<c;t++)n.push([s,e])}}}return n}(e,n,o),this.anchors=s.tensor2d(this.anchorsData),this.inputSizeData=[e,n],this.inputSize=s.tensor1d([e,n]),this.iouThreshold=r,this.scoreThreshold=a}async getBoundingBoxes(t,e,o=!0){const[i,r,a]=s.tidy(()=>{const e=t.resizeBilinear([this.width,this.height]),n=s.mul(s.sub(e.div(255),.5),2),o=this.blazeFaceModel.predict(n).squeeze(),i=function(t,e,n){const o=s.slice(t,[0,1],[-1,2]),i=s.add(o,e),r=s.slice(t,[0,3],[-1,2]),a=s.div(r,n),c=s.div(i,n),h=s.div(a,2),l=s.sub(c,h),d=s.add(c,h),u=s.mul(l,n),p=s.mul(d,n);return s.concat2d([u,p],1)}(o,this.anchors,this.inputSize),r=s.slice(o,[0,0],[-1,1]);return[o,i,s.sigmoid(r).squeeze()]}),c=console.warn;console.warn=()=>{};const h=s.image.nonMaxSuppression(r,a,this.maxFaces,this.iouThreshold,this.scoreThreshold);console.warn=c;const l=await h.array();h.dispose();let d=l.map(t=>s.slice(r,[t,0],[1,-1]));e||(d=await Promise.all(d.map(async t=>{const e=await t.array();return t.dispose(),e})));const u=t.shape[1],p=t.shape[2];let f;f=e?s.div([p,u],this.inputSize):[p/this.inputSizeData[0],u/this.inputSizeData[1]];const m=[];for(let t=0;t<d.length;t++){const r=d[t],c=s.tidy(()=>{const c=n(r instanceof s.Tensor?r:s.tensor2d(r));if(!o)return c;const h=l[t];let d;return d=e?this.anchors.slice([h,0],[1,2]):this.anchorsData[h],{box:c,landmarks:s.slice(i,[h,5],[1,-1]).squeeze().reshape([6,-1]),probability:s.slice(a,[h],[1]),anchor:d}});m.push(c)}return r.dispose(),a.dispose(),i.dispose(),{boxes:m,scaleFactor:f}}async estimateFaces(t,e=!1,n=!1,o=!0){const[,a]=function(t){return t instanceof s.Tensor?[t.shape[0],t.shape[1]]:[t.height,t.width]}(t),c=s.tidy(()=>(t instanceof s.Tensor||(t=s.browser.fromPixels(t)),t.toFloat().expandDims(0))),{boxes:h,scaleFactor:l}=await this.getBoundingBoxes(c,e,o);return c.dispose(),e?h.map(t=>{const e=r(t,l);let s={topLeft:e.slice([0],[2]),bottomRight:e.slice([2],[2])};if(o){const{landmarks:e,probability:n,anchor:o}=t,i=e.add(o).mul(l);s.landmarks=i,s.probability=n}return n&&(s=i(s,a)),s}):Promise.all(h.map(async t=>{const e=r(t,l);let s;if(o){const[n,o,i]=await Promise.all([t.landmarks,e,t.probability].map(async t=>t.array())),r=t.anchor,[a,c]=l,h=n.map(t=>[(t[0]+r[0])*a,(t[1]+r[1])*c]);s={topLeft:o.slice(0,2),bottomRight:o.slice(2),landmarks:h,probability:i},(t=>{t.startEndTensor.dispose(),t.startPoint.dispose(),t.endPoint.dispose()})(t.box),t.landmarks.dispose(),t.probability.dispose()}else{const t=await e.array();s={topLeft:t.slice(0,2),bottomRight:t.slice(2)}}return e.dispose(),n&&(s=i(s,a)),s}))}}const c={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]};function h(t){null!=t&&null!=t.startPoint&&(t.startEndTensor.dispose(),t.startPoint.dispose(),t.endPoint.dispose())}function l(t,e,n){return{startEndTensor:t,startPoint:null!=e?e:s.slice(t,[0,0],[-1,2]),endPoint:null!=n?n:s.slice(t,[0,2],[-1,2])}}function d(t){return s.tidy(()=>{const e=s.sub(t.endPoint,t.startPoint);return s.abs(e)})}function u(t,e=1.5){return s.tidy(()=>{const n=function(t){return s.tidy(()=>{const e=s.div(s.sub(t.endPoint,t.startPoint),2);return s.add(t.startPoint,e)})}(t),o=d(t),i=s.mul(s.div(o,2),e),r=s.sub(n,i),a=s.add(n,i);return l(s.concat2d([r,a],1),r,a)})}class p{constructor(t,e,s,n,o,i){this.regionsOfInterest=[],this.runsWithoutFaceDetector=0,this.boundingBoxDetector=t,this.meshDetector=e,this.meshWidth=s,this.meshHeight=n,this.maxContinuousChecks=o,this.maxFaces=i}async predict(t){if(this.shouldUpdateRegionsOfInterest()){const e=!0,n=!1,{boxes:o,scaleFactor:i}=await this.boundingBoxDetector.getBoundingBoxes(t,e,n);if(0===o.length)return i.dispose(),this.clearAllRegionsOfInterest(),null;const r=o.map(t=>u(function(t,e){const n=s.mul(t.startPoint,e),o=s.mul(t.endPoint,e);return l(s.concat2d([n,o],1))}(t,i)));o.forEach(h),this.updateRegionsOfInterest(r),this.runsWithoutFaceDetector=0}else this.runsWithoutFaceDetector++;return s.tidy(()=>this.regionsOfInterest.map((e,n)=>{const o=function(t,e,n){const o=e.shape[1],i=e.shape[2],r=t.startEndTensor;return s.tidy(()=>{const t=s.concat2d([r.slice([0,1],[-1,1]),r.slice([0,0],[-1,1]),r.slice([0,3],[-1,1]),r.slice([0,2],[-1,1])],0),a=s.div(t.transpose(),[o,i,o,i]);return s.image.cropAndResize(e,a,[0],n)})}(e,t,[this.meshHeight,this.meshWidth]).div(255),[,i,r]=this.meshDetector.predict(o),a=s.reshape(r,[-1,3]),c=s.div(d(e),[this.meshWidth,this.meshHeight]),l=s.mul(a,c.concat(s.tensor2d([1],[1,1]),1)).add(e.startPoint.concat(s.tensor2d([0],[1,1]),1)),u=this.calculateLandmarksBoundingBox(l);return h(this.regionsOfInterest[n]),this.regionsOfInterest[n]=u,{coords:a,scaledCoords:l,box:u,flag:i.squeeze()}}))}updateRegionsOfInterest(t){for(let e=0;e<t.length;e++){const s=t[e],n=this.regionsOfInterest[e];let o=0;if(n&&n.startPoint){const[t,e,i,r]=s.startEndTensor.arraySync()[0],[a,c,h,l]=n.startEndTensor.arraySync()[0],d=Math.max(t,a),u=Math.max(e,c),p=(Math.min(i,h)-d)*(Math.min(r,l)-u);o=p/((i-t)*(r-e)+(h-a)*(l-e)-p)}o>.25?h(s):(this.regionsOfInterest[e]=s,h(n))}for(let e=t.length;e<this.regionsOfInterest.length;e++)h(this.regionsOfInterest[e]);this.regionsOfInterest=this.regionsOfInterest.slice(0,t.length)}clearRegionOfInterest(t){null!=this.regionsOfInterest[t]&&(h(this.regionsOfInterest[t]),this.regionsOfInterest=[...this.regionsOfInterest.slice(0,t),...this.regionsOfInterest.slice(t+1)])}clearAllRegionsOfInterest(){for(let t=0;t<this.regionsOfInterest.length;t++)h(this.regionsOfInterest[t]);this.regionsOfInterest=[]}shouldUpdateRegionsOfInterest(){const t=this.regionsOfInterest.length,e=0===t;return 1===this.maxFaces||e?e:t!==this.maxFaces&&this.runsWithoutFaceDetector>=this.maxContinuousChecks}calculateLandmarksBoundingBox(t){const e=t.slice([0,0],[468,1]),n=t.slice([0,1],[468,1]);return u(l(s.stack([e.min(),n.min(),e.max(),n.max()]).expandDims(0)))}}async function f(t,s,n){return async function({maxFaces:t=10,inputWidth:s=128,inputHeight:n=128,iouThreshold:o=.3,scoreThreshold:i=.75}={}){const r=await e.loadGraphModel("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0});return new a(r,s,n,t,o,i)}({maxFaces:t,iouThreshold:s,scoreThreshold:n})}async function m(){return e.loadGraphModel("https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1",{fromTFHub:!0})}function g(t,e){if(t.mesh instanceof s.Tensor){const[n,o,i,r]=s.tidy(()=>{const n=s.tensor1d([e-1,0,0]),o=s.tensor1d([1,-1,1]);return s.tidy(()=>[s.concat([s.sub(e-1,t.boundingBox.topLeft.slice(0,1)),t.boundingBox.topLeft.slice(1,1)]),s.concat([s.sub(e-1,t.boundingBox.bottomRight.slice(0,1)),t.boundingBox.bottomRight.slice(1,1)]),s.sub(n,t.mesh).mul(o),s.sub(n,t.scaledMesh).mul(o)])});return Object.assign({},t,{boundingBox:{topLeft:n,bottomRight:o},mesh:i,scaledMesh:r})}return Object.assign({},t,{boundingBox:{topLeft:[e-1-t.boundingBox.topLeft[0],t.boundingBox.topLeft[1]],bottomRight:[e-1-t.boundingBox.bottomRight[0],t.boundingBox.bottomRight[1]]},mesh:t.mesh.map(t=>{const s=t.slice(0);return s[0]=e-1-t[0],s}),scaledMesh:t.scaledMesh.map(t=>{const s=t.slice(0);return s[0]=e-1-t[0],s})})}class b{constructor(t,e,s,n,o){this.pipeline=new p(t,e,192,192,s,o),this.detectionConfidence=n}static getAnnotations(){return c}async estimateFaces(t,e=!1,n=!1){const[,o]=function(t){return t instanceof s.Tensor?[t.shape[0],t.shape[1]]:[t.height,t.width]}(t),i=s.tidy(()=>(t instanceof s.Tensor||(t=s.browser.fromPixels(t)),t.toFloat().expandDims(0))),r=s.env().get("WEBGL_PACK_DEPTHWISECONV");s.env().set("WEBGL_PACK_DEPTHWISECONV",!0);const a=await this.pipeline.predict(i);return s.env().set("WEBGL_PACK_DEPTHWISECONV",r),i.dispose(),null!=a&&a.length>0?Promise.all(a.map(async(t,s)=>{const{coords:i,scaledCoords:r,box:a,flag:h}=t;let l=[h];e||(l=l.concat([i,r,a.startPoint,a.endPoint]));const d=await Promise.all(l.map(async t=>t.array())),u=d[0];if(h.dispose(),u<this.detectionConfidence&&this.pipeline.clearRegionOfInterest(s),e){const t={faceInViewConfidence:u,mesh:i,scaledMesh:r,boundingBox:{topLeft:a.startPoint.squeeze(),bottomRight:a.endPoint.squeeze()}};return n?g(t,o):t}const[p,f,m,b]=d.slice(1);r.dispose(),i.dispose();let y={faceInViewConfidence:u,boundingBox:{topLeft:m,bottomRight:b},mesh:p,scaledMesh:f};n&&(y=g(y,o));const x={};for(const t in c)x[t]=c[t].map(t=>y.scaledMesh[t]);return y.annotations=x,y})):[]}}class y{constructor(t,e){this.eyeblinkModel=t,this.facemeshModel=e}extractEyeBoundingBox(t,[e,s,n,o]){const i=t.scaledMesh[e][1],r=t.scaledMesh[s][0],a=t.scaledMesh[n][1];return{topLeft:[t.scaledMesh[o][0],i],bottomRight:[r,a]}}async getPredictionWithinBoundingBox(t,e){const n=s.tidy(()=>{const n=e.map(e=>[e.topLeft[1]/t.shape[0],e.topLeft[0]/t.shape[1],e.bottomRight[1]/t.shape[0],e.bottomRight[0]/t.shape[1]]);return s.image.cropAndResize(t.expandDims(0),n,n.map(()=>0),[26,34]).toFloat().mean(3).expandDims(3).toFloat().div(255)}),o=await async function(t){const e=await t.data();for(let s=0;s<t.shape[0];++s){let n=0,o=1;for(let i=0;i<t.strides[0];++i){let r=s*t.strides[0]+i;n=Math.max(n,e[r]),o=Math.min(o,e[r])}for(let i=0;i<t.strides[0];++i){let r=s*t.strides[0]+i;e[r]=(e[r]-o)/(n-o)}}return s.tensor1d(e).reshape(t.shape)}(n),i=this.eyeblinkModel.predict(o),r=await i.data();return o.dispose(),i.dispose(),r}async predictEyeOpenness(t,e){if(!(t instanceof s.Tensor)){const n=s.browser.fromPixels(t),o=await this.predictEyeOpenness(n,e);return n.dispose(),o}if(!e){const s=await this.facemeshModel.estimateFaces(t);if(0===s.length)return null;e=s[0]}const n=this.extractEyeBoundingBox(e,[27,243,23,130]),o=this.extractEyeBoundingBox(e,[257,359,253,362]),[i,r]=await this.getPredictionWithinBoundingBox(t,[n,o]);return{right:i,left:r}}}async function x(t="https://VanityXR.github.io/eyeblink/models/model.json"){return e.loadGraphModel(t)}t.Eyeblink=y,t.getImageData=function(t){const e=t.width,s=t.height,n=new OffscreenCanvas(e,s),o=n.getContext("2d");return o.drawImage(t,0,0,n.width,n.height),o.getImageData(0,0,n.width,n.height)},t.load=async function(t="https://VanityXR.github.io/eyeblink/models/model.json"){const e=await x(t),s=await async function({maxContinuousChecks:t=5,detectionConfidence:e=.9,maxFaces:s=10,iouThreshold:n=.3,scoreThreshold:o=.75}={}){const[i,r]=await Promise.all([f(s,n,o),m()]);return new b(i,r,t,e,s)}({maxFaces:1});return new y(e,s)},t.loadModel=x,Object.defineProperty(t,"__esModule",{value:!0})}));
